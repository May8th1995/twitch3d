<!DOCTYPE html>
<html>
    <head>
        <title>Twitch3D</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
        <link href="https://hjjg200.github.io/fonts/GmarketSans/GmarketSans.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">

        <style>
* {
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    -ms-appearance: none;
    box-sizing: border-box;
    text-size-adjust: none;
    -webkit-text-size-adjust: 100%;

    margin: 0;
    padding: 0;
    outline: none;
    border: none;
}

html, body {
    background: black;
    font-size: 16px;
    font-family: Roboto, Helvetica, Arial, sans-serif;
    line-height: 1.5;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
}
body.lang-ko {
    font-family: 'Noto Sans KR', sans-serif;
}

h1, h2, h3, h4 {
    font-family: Poppins, sans-serif;
    letter-spacing: -0.025rem;
}
body.lang-ko h1,
body.lang-ko h2,
body.lang-ko h3,
body.lang-ko h4 {
    font-family: 'Gmarket Sans', sans-serif;;
    font-weight: 400;
}

main {
    width: 100%;
    height: 100%;
}

button {
    border: none;
    outline: none;
    color: white;
    background: #9146FF;
    font-weight: bold;
    font-size: .8rem;
    padding: .4rem .7rem;
    border-radius: .3rem;
}

button:hover {
    background: rgb(166, 107, 255);
}

iframe {
    pointer-events: none;
}

input[type='text'] {
    background: rgba(0, 0, 0, 0.1);
    border-radius: .3rem;
    padding: .4rem .6rem;
}
input[type='text']:hover {
    box-shadow: 0 0 0 .125rem rgba(0, 0, 0, 0.15) inset;
}
input[type='text']:focus {
    box-shadow: 0 0 0 .125rem #9146FF inset;
    background: white;
}

/* Specific */

body.still-cursor main {
    cursor: none !important;
}
body.still-cursor .window.twitch-offline {
    opacity: 0;
}

button.button-cancel {
    background: rgba(0, 0, 0, 0.1);
    color: #444;
}
button.button-cancel:hover {
    background: rgba(0, 0, 0, 0.15);
}

#introduction {
    color: white;
    font-size: 1.2rem;
    width: 24rem;
    height: fit-content;
    top: 50%;
    left: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
}

/* NEW STYLE */
:root {
    --title-bar-height: 1.5rem;
    --corner-width: 1.2rem;
    --corner-edge-width: 0.4rem;
    --color-twitch: #9146FF;
    --color-gray-3: rgba(0, 0, 0, 0.1);
}

.frame {
    display: flex;
    flex-wrap: wrap;
    gap: .4rem;
}
.frame > * {
    display: inline-flex;
}
.frame-vertical {flex-direction: column;}
.frame-ralign {
    justify-content: flex-end;
}

body.fullscreen #btn-fullscreen,
body:not(.fullscreen) #btn-exit-fullscreen {
    display: none;
}

#context-menu {
    box-shadow: 0 0 .8rem rgba(0, 0, 0, 0.3);
    display: none;
    width: fit-content;
    background: white;
    position: absolute;
    z-index: 2001;
    overflow: hidden;
    padding: 0;
    border-radius: .2rem;
}
#context-menu-content {
    position: relative;
}
#context-menu ul {
    list-style: none;
}
#context-menu ul li {
    display: block;
}
#context-menu button {
    background: none;
    border-radius: 0;
    color: #444;
    display: block;
    width: 100%;
    height: 100%;
    line-height: 1;
    font-size: .85rem;
    padding: .5rem 4rem .5rem .6rem;
    font-weight: normal;
    text-align: left;
}
#context-menu button:hover {
    background: var(--color-twitch);
    color: white;
}

.modal {
    background: rgba(0, 0, 0, 0.4);
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2000;
}
.modal-content {
    background: white;
    position: relative;
    font-size: .8rem;
    padding: 1rem;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: fit-content;
}

.modal-buttons {
    margin-top: 1rem;
}

label {
    display: flex;
    vertical-align: middle;
}
label > *:not(:last-child) {
    margin-right: .3rem;
}

input[type='checkbox'] {
    background-color: var(--color-gray-3);
    border-radius: .3rem;
    width: 1rem;
    height: 1rem;
    display: inline-block;
}
input[type='checkbox']:checked {
    background-color: var(--color-twitch);
    background-image: url(svg/check.svg);
    background-repeat: no-repeat;
    background-position: 50% 50%;
    background-size: auto 50%;
}

#modal-add-stream #input-streamer {
    width: 15rem;
}

#modal-add-stream .inputs {
    margin-top: 3rem;
    margin-bottom: 1rem;
}

/* WINDOW */
.window {
    position: absolute;
    background: black;
    box-shadow: 0 .2rem .2rem rgba(0, 0, 0, 0);
    transition: box-shadow cubic-bezier(0.785, 0.135, 0.15, 0.86) 1s,
        opacity cubic-bezier(0.785, 0.135, 0.15, 0.86) 1s;
    opacity: 1;
}
body:not(.still-cursor) .window.focused {
    box-shadow: 0 .2rem 1rem rgba(0, 0, 0, 0.3);
}
.window.maximized {
    transform: none !important;
}
.window.maximized-xAxis.maximized-yAxis {
    z-index: 0 !important;
}
.window.maximized-xAxis {
    left: 0 !important;
    width: 100% !important;
}
.window.maximized-yAxis {
    top: 0 !important;
    height: 100% !important;
}
.window.in-move .corner {
    display: none;
}
.window-relative {
    position: relative;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.window-title-bar {
    background: var(--color-twitch);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: var(--title-bar-height);
    opacity: 1;
    transition: opacity cubic-bezier(0.33, 1, 0.68, 1) .3s;
}
.window:not(.in-move):not(.in-resize) .window-title-bar:not(:hover) {
    opacity: 0;
}
.window-title-bar-relative,
.window-title {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.window-title-bar-relative {
    position: relative;
}
.window-title-text {
    color: white;
    position: absolute;
    text-align: center;
    font-size: 0.9rem;
    line-height: 0;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: translateY(60%);
    user-select: none;
    -webkit-user-select: none;
}
.window-controls {
    position: absolute;
    right: 0;
    top: 0;
    height: 100%;
}
.window-controls button {
    background: none;
    border-radius: 0;
    width: 2.625rem;
    height: 100%;
}
.window-controls .button-maximize {
    background-image: url(svg/maximize.svg);
    background-repeat: no-repeat;
    background-position: 50% 50%;
    background-size: auto 50%;
}
.window-controls .button-close {
    background-color: #FF354D;
    background-image: url(svg/close.svg);
    background-repeat: no-repeat;
    background-position: 50%, 50%;
    background-size: auto 53%;
}
.window .corner {
    transform: translate(-50%, -50%);
    position: absolute;
}
.window.in-move .corner,
.window:not(.focused) .corner,
.window.maximized-xAxis.maximized-yAxis .corner {
    display: none;
}
.window .corner-top,
.window .corner-bottom {
    cursor: ns-resize;
    left: 50%;
    width: 100%;
    height: var(--corner-edge-width);
}
.window .corner-bottom {top: 100%;}
.window .corner-left,
.window .corner-right {
    cursor: ew-resize;
    top: 50%;
    width: var(--corner-edge-width);
    height: 100%;
}
.window .corner-right {left: 100%;}
.window .corner-top-left,
.window .corner-top-right,
.window .corner-bottom-right,
.window .corner-bottom-left {
    width: var(--corner-width);
    height: var(--corner-width);
}
.window .corner-top-left,
.window .corner-bottom-right {
    cursor: nwse-resize;
}
.window .corner-top-right,
.window .corner-bottom-left {
    cursor: nesw-resize;
}
.window .corner-top-right {left: 100%;}
.window .corner-bottom-right {left: 100%; top: 100%;}
.window .corner-bottom-left {top: 100%;}
.window-content-overlay,
.window-content,
.window-content > * {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    position: absolute;
}
.window iframe {
    pointer-events: none;
}
.window.iframe-enabled iframe {
    pointer-events: all;
}
@keyframes iframe-hint {
    from {
        background: rgba(255, 255, 255, 0.3);
    }
    to {
        background: rgba(255, 255, 255, 0);
    }
}
.window.iframe-enabled .window-content-overlay {
    box-shadow: 0 0 1rem rgba(92, 152, 255, 0.75) inset; /* visual hint */
    animation: cubic-bezier(0, 0.55, 0.45, 1) 1.5s 1 iframe-hint;
    pointer-events: none;
}

#window-connections-indicator {
    display: none;
    position: absolute;
    box-shadow: 0 0 0 2px #FF3D00;
}
        </style>
    </head>
    <body>
        <main>
            <div id="introduction">
                <h1>This Is Twitch3D</h1>
                <p>Press <b>Right Mouse Button</b> to open up menu and add your favorite Twitch channels!</p>
                <div class="frame frame-ralign">
                </div>
            </div>
            <div id="window-connections-indicator"></div>
            <div id="streams-container">

            </div>
        </main>
        <div id="context-menu">
            <div id="context-menu-content">
                <ul id="context-menu-items">
                    <li>
                        <button id="btn-add-stream">Add Channel</button>
                    </li>
                    <li>
                        <button id="btn-fullscreen">Fullscreen</button>
                    </li>
                    <li>
                        <button id="btn-exit-fullscreen">Exit Fullscreen</button>
                    </li>
                    <li>
                        <button id="btn-github">GitHub</button>
                    </li>
                </ul>
            </div>
        </div>
        <div id="modal-add-stream" class="modal">
            <div class="modal-content">
                <h2>Add Channel</h2>
                <p>Enter the Twitch ID of the streamer</p>
                <div class="inputs frame frame-vertical">
                    <label for="input-with-chat">
                        <input type="checkbox" id="input-with-chat">
                        <span>Include Chat</span>
                    </label>
                    <label for="input-streamer">
                        <input type="text" id="input-streamer">
                    </label>
                </div>
                <div class="frame frame-ralign modal-buttons">
                    <button class="button button-ok">OK</button>
                    <button class="button button-cancel">Cancel</button>
                </div>
            </div>
        </div>

        <script src= "https://player.twitch.tv/js/embed/v1.js"></script>
        <script>

const lang = navigator.language.slice(0, 2);
const locales = {
    "ko": {
        "#introduction h1": "트위치3D",
        "#introduction p": "<b>오른쪽 마우스 버튼</b>으로 메뉴를 열어서 스트리머들을 추가해보세요!",
        "#btn-add-stream": "채널 추가",
        "#btn-fullscreen": "전체화면",
        "#btn-exit-fullscreen": "전체화면 나가기",
        "#add-stream-modal h2": "채널 추가",
        "#add-stream-modal h2 + p": "추가할 스트리머의 Twitch 아이디를 입력하세요",
        ".button-ok": "확인",
        ".button-cancel": "취소"
    }
};
if(locales[lang] !== undefined) {
    document.body.classList.add(`lang-${lang}`);
    for(const key in locales[lang]) {
        for(const el of document.querySelectorAll(key).values()) {
            el.innerHTML = locales[lang][key];
        }
    }
}

const streamsContainer = document.getElementById("streams-container");

const createElement = (tag, ...classes) => {
    const element = document.createElement(tag);
    element.classList.add(...classes);
    return element;
};

// Mouse tracker
let mouseX = 0;
let mouseY = 0;
let mouseThrottled = false;
let mouseHideHandler = null;
const mouseHandler = (event) => {
    if(mouseThrottled) return;
    mouseThrottled = true;
    document.body.classList.remove("still-cursor");
    mouseX = Rem.fromPixel(event.pageX);
    mouseY = Rem.fromPixel(event.pageY);
    // Hiding cursor
    if(mouseHideHandler !== null) clearTimeout(mouseHideHandler);
    mouseHideHandler = setTimeout(((x, y) => {
        if(mouseX === x && mouseY === y) {
            document.body.classList.add("still-cursor");
        }
    }).bind(null, mouseX, mouseY), 3000);
    //
    setTimeout(() => {
        mouseThrottled = false;
    }, 16);
};
document.addEventListener("mousemove", mouseHandler);

// Class Rem
class Rem {
    static get fontSize() {
        return parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    static toPixel(rem) {
        return rem * Rem.fontSize;
    }
    static toString(rem) {
        return `${rem}rem`;
    }
    static fromPixel(px) {
        return px / this.fontSize;
    }
    static fromString(str) {
        return parseFloat(str.trim().replace("rem", ""));
    }
};

// Class DLL for window indexing
class DLL {
    constructor() {
        this._map = {};
        this.head = null;
    }
    get length() {
        return Object.keys(this._map).length;
    }
    values() {
        return Object.values(this._map).map((v) => v.value);
    }
    remove(key) {
        const node = this._map[key];
        const next = node.next;
        const prev = node.prev;
        if(next !== null) next.prev = prev;
        if(prev !== null) prev.next = next;
        if(this.head === node) this.head = prev;
        delete this._map[key];
    }
    get(key) {
        return this._map[key].value;
    }
    put(key, value) {
        const oldHead = this.head;
        this.head = {
            value: value,
            next: null,
            prev: oldHead
        };
        this._map[key] = this.head;
        if(oldHead !== null) {
            oldHead.next = this.head;
        }
    }
}

// Class Window
class Window {
    static baseZIndex = 1;
    static windows = new DLL();
    static groups = [];
    static autoIncrement = 0;
    static newId() {
        return `window-${(new Date()).getTime()}-${this.autoIncrement++}`;
    }
    static overrideFallback = {
        id: null,
        connectedTo: null,
        xMaximized: false,
        yMaximized: false,
        anchor: null,
        anchorPosition: null
    };

    constructor({top, left, width, height}, overrides) {
        // TODO: create window
        overrides = {...Window.overrideFallback, ...overrides};
        const id = overrides.id || Window.newId();
        this.element = createElement("div", "window");
        this.element.id = id;
        this.element.style.top = Rem.toString(top);
        this.element.style.left = Rem.toString(left);
        this.element.style.width = Rem.toString(width);
        this.element.style.height = Rem.toString(height);
        this.element.style.zIndex = `${Window.windows.length + Window.baseZIndex}`;
        this.addEventListener = this.element.addEventListener.bind(this.element);
        this.dispatchEvent = this.element.dispatchEvent.bind(this.element);
        //  div.window
        //      div.window-relative
        //          div.window-content
        //          div.window-content-overlay
        //          div.window-title-bar
        //              div.window-title-bar-relative
            //              div.window-title
            //                  div.window-title-text
            //              div.window-controls
            //                  button.button-maximize
            //                  button.button-close
        //          div.corner.corner-top
        //          div.corner.corner-right
        //          div.corner.corner-bottom
        //          div.corner.corner-left
        //          div.corner.corner-top-left
        //          div.corner.corner-top-right
        //          div.corner.corner-bottom-right
        //          div.corner.corner-bottom-left

        // Relative
        const relative = createElement("div", "window-relative");

        // Window content
        this.contentElement = createElement("div", "window-content");
        this.contentElement.id = `${this.id}-content`;
        const contentOverlay = createElement("div", "window-content-overlay");

        let ctxMenuWasNotOpen = true;
        contentOverlay.addEventListener("mousedown", (ev) => {
            ctxMenuWasNotOpen = ctxMenu.style.display === "";
        });
        contentOverlay.addEventListener("mouseup", ((ev) => {
            this.focus();
            if(ev.button === 0 && ctxMenuWasNotOpen) {
                enableIframe(this);
            }
        }).bind(this));

        relative.appendChild(this.contentElement);
        relative.appendChild(contentOverlay);

        // Title bar
        const titleBar = createElement("div", "window-title-bar");
        const titleBarRelative = createElement("div", "window-title-bar-relative");
        const title = createElement("div", "window-title");
        const titleText = createElement("div", "window-title-text");
        const controls = createElement("div", "window-controls");
        const btnMaximize = createElement("button", "button-maximize");
        const btnClose = createElement("button", "button-close");

        title.addEventListener("mousedown", ((ev) => {
            this.focus();
            if(ev.button === 0) Window._startResize(this, 0, 0);
        }).bind(this));

        title.appendChild(titleText);
        titleBarRelative.appendChild(title);

        btnClose.addEventListener("mouseup", ((ev) => {
            if(ev.button === 0) this.close();
        }).bind(this));
        btnMaximize.addEventListener("mouseup", ((ev) => {
            if(ev.button === 0) this.maximize(true, true);
        }).bind(this));
        title.addEventListener("dblclick", ((ev) => {
            if(ev.button === 0) this.maximize(true, true);
        }).bind(this));

        controls.appendChild(btnMaximize);
        controls.appendChild(btnClose);
        titleBarRelative.appendChild(controls);
        titleBar.appendChild(titleBarRelative);
        relative.appendChild(titleBar);
        // Corners
        const cornerTop = createElement("div", "corner", "corner-top");
        const cornerRight = createElement("div", "corner", "corner-right");
        const cornerBottom = createElement("div", "corner", "corner-bottom");
        const cornerLeft = createElement("div", "corner", "corner-left");
        const cornerTopLeft = createElement("div", "corner", "corner-top-left");
        const cornerTopRight = createElement("div", "corner", "corner-top-right");
        const cornerBottomRight = createElement("div", "corner", "corner-bottom-right");
        const cornerBottomLeft = createElement("div", "corner", "corner-bottom-left");

        // Corner edges
        cornerTop.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, 1, 0);
        }).bind(this));
        cornerTop.addEventListener("dblclick", ((ev) => {
            if(ev.button === 0) this.maximize(false, true);
        }).bind(this));
        cornerRight.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, 0, -1);
        }).bind(this));
        cornerRight.addEventListener("dblclick", ((ev) => {
            if(ev.button === 0) this.maximize(true, false);
        }).bind(this));
        cornerBottom.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, -1, 0);
        }).bind(this));
        cornerBottom.addEventListener("dblclick", ((ev) => {
            if(ev.button === 0) this.maximize(false, true);
        }).bind(this));
        cornerLeft.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, 0, 1);
        }).bind(this));
        cornerLeft.addEventListener("dblclick", ((ev) => {
            if(ev.button === 0) this.maximize(true, false);
        }).bind(this));
        // Corners
        cornerTopLeft.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, 1, 1);
        }).bind(this));
        cornerTopRight.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, 1, -1);
        }).bind(this));
        cornerBottomRight.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, -1, -1);
        }).bind(this));
        cornerBottomLeft.addEventListener("mousedown", ((ev) => {
            if(ev.button === 0) Window._startResize(this, -1, 1);
        }).bind(this));

        relative.appendChild(cornerTop);
        relative.appendChild(cornerRight);
        relative.appendChild(cornerBottom);
        relative.appendChild(cornerLeft);
        relative.appendChild(cornerTopLeft);
        relative.appendChild(cornerTopRight);
        relative.appendChild(cornerBottomRight);
        relative.appendChild(cornerBottomLeft);

        // Append
        this.element.appendChild(relative);
        streamsContainer.appendChild(this.element);
        Window.windows.put(id, this);
        this.focus();

        // Maximize
        if(overrides.xMaximized || overrides.yMaximized) this.maximize(overrides.xMaximized, overrides.yMaximized);

        // Genenral properties
        this.anchorPosition = Window.anchorPositionOf(this.rect(), Rem.fromPixel(window.innerWidth), Rem.fromPixel(window.innerHeight));
        this.connectedTo = overrides.connectedTo || {};
        [this.tbAnchor, this.lbAnchor] = overrides.anchor || [0, 0];
        const [ww, wh] = windowDimensions();
        this.anchorPosition = overrides.anchorPosition || Window.anchorPositionOf(this.rect(), ww, wh);

        //
        this.addEventListener("change", () => {
            Window.storeSerialization();
        });
        this.dispatchEvent(new Event("change"));

    }
    get id() {
        return this.element.id;
    }
    setTitle(title/*: string*/) {
        this.element.querySelector(".window-title-text").textContent = title;
    }
    close() {
        Window.windows.remove(this.id);
        this.element.parentNode.removeChild(this.element);

        this.dispatchEvent(new Event("change"));
    }
    static fullyMaximizedWindow = null;
    maximize(xAxis/*: boolean*/, yAxis/*: boolean*/) {
        if(this.isMaximized(false)) {
            this.unmaximize();
            this.dispatchEvent(new Event("change"));
            return;
        }
        if(xAxis && yAxis) {
            // Replace the maximized window
            if(Window.fullyMaximizedWindow !== null)
                Window.fullyMaximizedWindow.unmaximize();
            Window.fullyMaximizedWindow = this;
        }
        this.element.classList.add("maximized");
        xAxis && this.element.classList.add("maximized-xAxis");
        yAxis && this.element.classList.add("maximized-yAxis");
        this.dispatchEvent(new Event("change"));
        this.dispatchEvent(new Event("maximize"));
    }
    isMaximized(fully) {
        return fully
            ? this.element.matches(".maximized-xAxis.maximized-yAxis")
            : this.element.matches(".maximized");
    }
    unmaximize() {
        this.element.classList.remove("maximized", "maximized-xAxis", "maximized-yAxis");
        this.dispatchEvent(new Event("change"));
        this.dispatchEvent(new Event("maximize"));
    }
    focus() {
        // Move top level
        Window.windows.remove(this.id);
        Window.windows.put(this.id, this);
        let node = Window.windows.head;
        let headIndex = Window.windows.length + Window.baseZIndex - 1;
        while(node !== null) {
            node.value.element.style.zIndex = `${headIndex--}`;
            node.value.blur();
            node = node.prev;
        }
        //
        this.element.classList.add("focused");
    }
    blur() {
        this.element.classList.remove("focused");
    }
    rect(actual) {
        const sty = this.element.style;
        const rect = this.element.getBoundingClientRect();
        const [top, left, width, height] = [
            actual ? Rem.fromString(sty.top) : Rem.fromPixel(rect.top),
            actual ? Rem.fromString(sty.left) : Rem.fromPixel(rect.left),
            actual ? Rem.fromString(sty.width) : Rem.fromPixel(rect.width),
            actual ? Rem.fromString(sty.height) : Rem.fromPixel(rect.height)
        ];
        return {
            top,
            left,
            bottom: top + height,
            right: left + width,
            width,
            height,
            x: left,
            y: top
        };
    }
    get anchor() {
        let [tb, lr] = [this.tbAnchor, this.lrAnchor];
        return [
            this.element.matches(".maximized-yAxis") ? 0 : tb, // single-axis maximized always middle anchored
            this.element.matches(".maximized-xAxis") ? 0 : lr
        ];
    }
    distanceTo(win1) {
        const rect0 = this.rect(false);
        const rect1 = win1.rect(false);
        // tb distance
        let tb = 0;
        if(rect1.bottom < rect0.top)      tb = rect0.top - rect1.bottom;
        else if(rect1.top > rect0.bottom) tb = rect1.top - rect0.bottom;
        // lr distance
        let lr = 0;
        if(rect1.right < rect0.left)      lr = rect0.left - rect1.right;
        else if(rect1.left > rect0.right) lr = rect1.left - rect0.right;
        //
        let dist = Math.pow(tb*tb + lr*lr, 0.5);
        const epsilon = Rem.fromPixel(0.5);
        if(dist < epsilon) dist = 0;
        return dist;
    }
    connections() {
        const visited = {};
        const visit = (win0) => {
            if(win0.id in visited) return;
            visited[win0.id] = win0;
            for(const id1 of Object.keys(win0.connectedTo)) {
                visit(Window.windows.get(id1));
            }
        };
        visit(this);
        return visited;
    }

    // TODO: tbAnchor, lrAnchor
    // TODO: window groups
    //          - delete group when there is no 0-distanced windows
    //              - consider actual coords
    //          - form group when snapping, exclude fully maximized window
    //              - snapping is done on actual coords
    //          - group indicator is visible when cursor is hovering on any of the group's window
    // TODO: repositioning windows when window resized is done in this order
    //          - each group as a whole
    //          - windows that don't belong to any group
    static anchorOf(rect) {
        const ww = Rem.fromPixel(window.innerWidth);
        const wh = Rem.fromPixel(window.innerHeight);
        let tb, lr;
        if(rect.x <= 0)                    lr = 1;
        else if(rect.x + rect.width >= ww) lr = -1;
        else                               lr = 0;
        if(rect.y <= 0)                     tb = 1;
        else if(rect.y + rect.height >= wh) tb = -1;
        else                                tb = 0;
        return [tb, lr];
    }
    static anchorPositionOf(rect, ww, wh) {
        return {
            top: rect.top,                               /* REM */
            middleTop: (rect.top + rect.height/2) / wh,  /* RATIO */
            bottom: wh - (rect.top + rect.height),       /* REM */
            left: rect.left,                             /* REM */
            middleLeft: (rect.left + rect.width/2) / ww, /* RATIO */
            right: ww - (rect.left + rect.width)         /* REM */
        };
    }
    static storeSerialization() {
        const serialization = this.serialize();
        localStorage.setItem("t3d-windows", serialization);
    }
    static serialize() {
        const ary = [];
        let n = this.windows.head;
        while(n !== null) {
            const v = n.value;
            ary.push({
                id: v.id,
                top: Rem.fromString(v.element.style.top),
                left: Rem.fromString(v.element.style.left),
                width: Rem.fromString(v.element.style.width),
                height: Rem.fromString(v.element.style.height),
                connectedTo: v.connectedTo,
                xMaximized: v.element.matches(".maximized-xAxis"),
                yMaximized: v.element.matches(".maximized-yAxis"),
                anchor: v.anchor,
                anchorPosition: v.anchorPosition
            });
            n = n.prev;
        }
        return JSON.stringify(ary.reverse());
    }
    static interpretSerialization(serialization) {
        const ary = JSON.parse(serialization);
        for(let i = 0; i < ary.length; i++) {
            const each = ary[i];
            new Window({
                top: each.top,
                left: each.left,
                width: each.width,
                height: each.height,
            }, {
                id: each.id,
                connectedTo: each.connectedTo,
                xMaximized: each.xMaximized,
                yMaximized: each.yMaximized,
                anchor: each.anchor,
                anchorPosition: each.anchorPosition
            });
        }
    }
    static _resizeHandler = null;
    static _minWidth = 9;
    static _minHeight = 6;
    static _stopResize = null;
    static deadZoneThreshold = 2;
    static stopResize() {
        if(this._stopResize !== null) {
            this._stopResize();
            this._stopResize = null;
        }
    }
    static _startResize(win, tbWise, lrWise) {

        disableIframes();

        // tbWise: 1=top, 0=none, -1=bottom
        // lrWise: 1=left, 0=none, -1=right
        // tbWise 0, lrWise 0 = moving window
        const el = win.element;
        const rect0 = win.rect(false);
        const [mouseX0, mouseY0] = [mouseX, mouseY];
        const width0 = Rem.fromString(el.style.width);
        const height0 = Rem.fromString(el.style.height);
        const top0 = rect0.y; // Get the shown position
        const left0 = (win.isMaximized(false) ? mouseX0 - width0/2 : rect0.x); // When maximized get middle position
        const connectedTo0 = {...win.connectedTo};
        const snapDist = Rem.fromPixel(10);
        const snapDgnDist = 1.41 * snapDist * 3; // Diagnoal distance is more generous
        const snapHelper = (origin, dests) => {
            // dir: -1=left or top, 1=right or bottom
            let ret = [false];
            for(let i = 0; i < dests.length; i++) {
                const dest = dests[i].value;
                const owner = dests[i].owner;
                if(owner !== null && win.distanceTo(owner) > snapDgnDist) continue;
                if(origin >= dest - snapDist && origin <= dest + snapDist)
                    ret = [true, dest - origin, owner];
            }
            return ret;
        };
        const tbDests = [];
        const lrDests = [];
        const ww = Rem.fromPixel(window.innerWidth);
        const wh = Rem.fromPixel(window.innerHeight);
        for(const win1 of this.windows.values()) {
            if(win1 === win) continue;
            const rect1 = win1.rect(false);
            const top1 = rect1.top;
            const left1 = rect1.left;
            tbDests.push({value: top1, owner: win1}, {value: top1 + rect1.height, owner: win1});
            lrDests.push({value: left1, owner: win1}, {value: left1 + rect1.width, owner: win1});
        }
        const tDests = [{value: 0, owner: null}, ...tbDests];
        const bDests = [{value: wh, owner: null}, ...tbDests];
        const lDests = [{value: 0, owner: null}, ...lrDests];
        const rDests = [{value: ww, owner: null}, ...lrDests];

        const ignoreMaximizedThreshold = Rem.fromPixel(10);

        // Show current connections
        Window.showConnectionsIndicator(win.connections());

        let connectCandidate = null; // other window to stick to
        let changed = false;
        let farthest = 0;
        this.stopResize();
        this._stopResize = (() => {
            win.element.classList.remove("in-move", "in-resize");
            if(this._resizeHandler !== null) {
                clearInterval(this._resizeHandler);
                this._resizeHandler = null;
            }
            //
            Window.hideConnectionsIndicator();
            win.dispatchEvent(new Event("change"));
        }).bind(this);
        this._resizeHandler = setInterval((() => {
            const dx = mouseX - mouseX0;
            const dy = mouseY - mouseY0;
            const d = Math.pow(dx*dx + dy*dy, 0.5);
            changed = changed || (dx !== 0 || dy !== 0);
            if(!changed) return;
            farthest = Math.max(farthest, d);
            if(win.isMaximized(false) && farthest <= ignoreMaximizedThreshold) return;
            if(win.isMaximized(false)) win.unmaximize();
            // TODO: xAxis maximized left

            // 0,0 = t,l only snap t,l
            // 1,0 = t,h only snap t,h
            // -1, 0 = h only snap h
            // 0,1 = l,w only snap l,w
            // 0,-1 = w only
            // 1,1 = t,h,w,l
            // -1,-1 = h,w
            // (tbWise === 1 or 0 && lrWise === 0) lrWise !== 0 && tbWise === 1

            // tbWise === 0 && lrWise !== -1 => l
            // tbWise !== 0 => h
            // lrWise === 0 && tbWise !== -1 => t
            // lrWise !== 0 => w
            let [top1, left1, width1, height1] = [top0, left0, width0, height0];
            const tok = lrWise === 0 ? tbWise >= 0 : tbWise === 1;
            const lok = tbWise === 0 ? lrWise >= 0 : lrWise === 1;
            const wok = lrWise !== 0;
            const hok = tbWise !== 0;
            const move = tbWise === 0 && lrWise === 0;

            // class
            el.classList.add(move ? "in-move" : "in-resize");

            top1 += (tok || move) ? dy : 0;
            left1 += (lok || move) ? dx : 0;
            width1 += wok ? (lrWise !== -1 ? -dx : dx) : 0;
            height1 += hok ? (tbWise !== -1 ? -dy : dy) : 0;

            // Out of boundary check
            if(top1 > wh - Window.deadZoneThreshold) {
                height1 += hok ? ((wh - Window.deadZoneThreshold) - top1) : 0;
                top1 = wh - Window.deadZoneThreshold;
            }
            if(top1 < 0) {
                height1 += hok ? top1 : 0;
                top1 = 0;
            }
            if(left1 > ww - Window.deadZoneThreshold) {
                width1 += wok ? ((ww - Window.deadZoneThreshold) - left1) : 0;
                left1 = ww - Window.deadZoneThreshold;
            }
            if(left1 + width1 < Window.deadZoneThreshold) {
                width1 += wok ? (Window.deadZoneThreshold - left1) : 0;
                left1 = Window.deadZoneThreshold - width1;
            }

            // Snapping
            connectCandidate = null;
            const ratioSnapThreshold = 2; /* REM */
            const ratioUnitLength = (height1 + width1) / (16+9);
            const snapRatio = 16 / 9;
            const ratioLowerBound = (ratioUnitLength*16 - ratioSnapThreshold) / (ratioUnitLength*9);
            const ratioUpperBound = (ratioUnitLength*16 + ratioSnapThreshold) / (ratioUnitLength*9);
            const ratio1 = width1 / height1;
            if(ratio1 <= ratioUpperBound
                && ratio1 >= ratioLowerBound
                && !move) {
                // Ratio snapping takes priority
                if(wok) {
                    // Height is standard
                    const oldw = width1;
                    width1 = height1 * snapRatio;
                    if(lok) left1 += oldw - width1;
                } else {
                    const oldh = height1;
                    height1 = width1 / snapRatio;
                    if(hok) top1 += oldh - height1;
                }
            } else {
                // Less priority
                if(tok || hok) {
                    const [ts, td, town] = snapHelper(top1, tDests);
                    const [bs, bd, bown] = snapHelper(top1 + height1, bDests);
                    let d = 0;
                    // Top takes priority
                    if(bs) {d = bd; connectCandidate = bown;}
                    if(ts) {d = td; connectCandidate = town;}
                    if(tok) top1 += d;
                    if(hok) height1 += tok ? -d : d;
                }
                if(lok || wok) {
                    const [ls, ld, lown] = snapHelper(left1, lDests);
                    const [rs, rd, rown] = snapHelper(left1 + width1, rDests);
                    let d = 0;
                    // Left takes priority
                    if(rs) {d = rd; connectCandidate = rown;}
                    if(ls) {d = ld; connectCandidate = lown;}
                    if(lok) left1 += d;
                    if(wok) width1 += lok ? -d : d;
                }
            }
       
            el.style.top = Rem.toString(top1);
            el.style.left = Rem.toString(left1);
            el.style.width = Rem.toString(width1);
            el.style.height = Rem.toString(height1);

            // Anchor
            const rect1 = win.rect(false);
            [win.tbAnchor, win.lrAnchor] = Window.anchorOf(rect1);
            win.anchorPosition = Window.anchorPositionOf(rect1, ww, wh);

            // Connections
            for(const id1 of Object.keys({...connectedTo0, ...win.connectedTo})) {
                const win1 = Window.windows.get(id1);
                if(win.distanceTo(win1) === 0) {
                    win.connectedTo[win1.id] = null;
                    win1.connectedTo[win.id] = null;
                } else {
                    delete win.connectedTo[win1.id];
                    delete win1.connectedTo[win.id];
                }
            }
            if(connectCandidate !== null && connectCandidate.distanceTo(win) === 0) {
                win.connectedTo[connectCandidate.id] = null;
            }
            if(Object.keys(win.connectedTo).length > 0) {
                Window.showConnectionsIndicator(win.connections());
            } else {
                Window.hideConnectionsIndicator();
            }
        }).bind(this), 16);
    }
    static showConnectionsIndicator(connections) {
        if(Object.keys(connections).length === 1) return;
        const rect = this.connectionsRect(connections, false);
        const gi = document.getElementById("window-connections-indicator");
        gi.style.top = Rem.toString(rect.top);
        gi.style.left = Rem.toString(rect.left);
        gi.style.width = Rem.toString(rect.width);
        gi.style.height = Rem.toString(rect.height);
        gi.style.display = "block";
    }
    static hideConnectionsIndicator() {
        const gi = document.getElementById("window-connections-indicator");
        gi.style.display = "";
    }
    static connectionsAnchor(connections) {
        const values = Object.values(connections);
        const anchors = values.map(v => v.anchor);
        // if any is tb anchor top, it's top
        // else bottom it's bottom
        // else middle
        const tbMax = Math.max(...anchors.map(v => v[0]));
        const tbMin = Math.min(...anchors.map(v => v[0]));
        const lrMax = Math.max(...anchors.map(v => v[1]));
        const lrMin = Math.min(...anchors.map(v => v[1]));
        let [tb, lr] = [0, 0];
        if(tbMax === 1)       tb = 1;
        else if(tbMin === -1) tb = -1;
        if(lrMax === 1)       lr = 1;
        else if(lrMin === -1) lr = -1;
        return [tb, lr];
    }
    static connectionsRect(connections, actual) {
        const values = Object.values(connections);
        const rects = values.map(v => v.rect(actual));
        const rect = {
            top: Math.min(...rects.map(v => v.top)),
            left: Math.min(...rects.map(v => v.left)),
            bottom: Math.max(...rects.map(v => v.bottom)),
            right: Math.max(...rects.map(v => v.right))
        };
        rect.x = rect.left;
        rect.y = rect.top;
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
        return rect;
    }
}
document.addEventListener("mouseup", () => {
    Window.stopResize();
});
let windowResizeTimeout = null;
const windowDimensions = () => {
    return [Rem.fromPixel(window.innerWidth), Rem.fromPixel(window.innerHeight)];
};
let [ww0, wh0] = windowDimensions();
window.addEventListener("resize", () => {
    if(windowResizeTimeout !== null) clearTimeout(windowResizeTimeout);
    windowResizeTimeout = setTimeout(() => {
        // 
        const [ww1, wh1] = windowDimensions();
        let repositioned = {};
        for(const win0 of Window.windows.values()) {
            if(win0.id in repositioned) continue;

            const connections = win0.connections();
            repositioned = {...repositioned, ...connections};
            const anchor = Window.connectionsAnchor(connections);
            const values = Object.values(connections);

            // Connections middle diff
            const rect = Window.connectionsRect(connections, true);
            const ap0 = Window.anchorPositionOf(rect, ww0, wh0);
            const mt = (rect.top + rect.height/2) / wh1;
            const ml = (rect.left + rect.width/2) / ww1;
            const dt = (ap0.middleTop - mt) * wh1;
            const dl = (ap0.middleLeft - ml) * ww1;
            
            for(const win1 of values) {
                const ap1 = win1.anchorPosition;
                const el = win1.element;
                const [w, h] = [Rem.fromString(el.style.width), Rem.fromString(el.style.height)];
                let t = Rem.fromString(el.style.top) + dt;
                let l = Rem.fromString(el.style.left) + dl;

                if(anchor[0] === 1) t = ap1.top;
                else if(anchor[0] === -1) t = wh1 - ap1.bottom - h;

                if(anchor[1] === 1) l = ap1.left;
                else if(anchor[1] === -1) l = ww1 - ap1.right - w;

                if(t > wh1 - Window.deadZoneThreshold) t = wh1 - Window.deadZoneThreshold;
                else if(t < 0) t = 0;
                if(l > ww1 - Window.deadZoneThreshold) l = ww1 - Window.deadZoneThreshold;
                else if(l < 0) l = 0;

                el.style.top = Rem.toString(t);
                el.style.left = Rem.toString(l);
            }
        }

        Window.storeSerialization();
        [ww0, wh0] = [ww1, wh1];
    }, 16);
});

const isContainedIn = (element, parent) => {
    if(element === parent) return true;
    let n = element.parentNode;
    while(n !== null) {
        if(n === parent) return true;
        n = n.parentNode;
    }
    return false;
}
const isContainedInSelector = (element, selector) => {
    if(element.matches(selector)) return true;
    let n = element.parentNode;
    while(n !== null && n.matches) {
        if(n.matches(selector)) return true;
        n = n.parentNode;
    }
    return false;
}

// Menu
const ctxMenu = document.getElementById("context-menu");
const ctxItems = document.getElementById("context-menu-items");
const modals = document.querySelectorAll(".modal");
const modalAddStream = document.getElementById("modal-add-stream");
const btnAddStream = document.getElementById("btn-add-stream");
const btnFullscreen = document.getElementById("btn-fullscreen");
const btnExitFullscreen = document.getElementById("btn-exit-fullscreen");
const btnGitHub = document.getElementById("btn-github");
document.addEventListener("contextmenu", (ev) => {
    ev.preventDefault();
    ctxMenu.style.display = "block";
    ctxMenu.style.top = Rem.toString(mouseY - Rem.fromPixel(3));
    ctxMenu.style.left = Rem.toString(mouseX + Rem.fromPixel(3));
});
document.addEventListener("mousedown", (ev) => {
    // disableIframeStreams();
    if(!isContainedIn(ev.target, ctxMenu)) {
        ctxMenu.style.display = "";
    }
});
document.addEventListener("mouseup", (ev) => {
    const t = ev.target;
    if(!isContainedInSelector(t, ".modal-content")
        && isContainedInSelector(t, ".modal")) {
        for(const modal of modals.values()) {
            modal.style.display = "";
        }
    }
});
ctxItems.addEventListener("mouseup", (ev) => {
    ctxMenu.style.display = "";
});
btnAddStream.addEventListener("mouseup", (ev) => {
    modalAddStream.dispatchEvent(new Event("modalopen"));
});
btnFullscreen.addEventListener("mouseup", (ev) => {
    document.body.requestFullscreen();
});
btnExitFullscreen.addEventListener("mouseup", (ev) => {
    document.exitFullscreen();
});
btnGitHub.addEventListener("mouseup", (ev) => {
    window.open("https://github.com/hjjg200/twitch3d", "_blank");
});
document.addEventListener("fullscreenchange", (ev) => {
    document.body.classList[document.fullscreenElement === null ? "remove" : "add"]("fullscreen");
});

{ // Add Stream Modal
    const btnOK = modalAddStream.querySelector(".button-ok");
    const btnCancel = modalAddStream.querySelector(".button-cancel");
    const streamer = modalAddStream.querySelector("#input-streamer");
    const withChat = modalAddStream.querySelector("#input-with-chat");
    let [o_mouseX, o_mouseY] = [0, 0]; // When modal gets open
    const addStreamHelper = () => {
        if(streamer.value === "") {
        
            return;
        }
        const channel = streamer.value;
        const streamWin = new Window({
            top: o_mouseY,
            left: o_mouseX,
            width: 32,
            height: 18
        });
        addTwitchComponent(streamWin, channel, false);
        if(withChat.checked === true) {
            const chatWin = new Window({
                top: o_mouseY + 2,
                left: o_mouseX + 2,
                width: 18,
                height: 30
            });
            addTwitchComponent(chatWin, channel, true);
        }
        // Reset
        streamer.value = "";
        withChat.checked = false;
        modalAddStream.style.display = "";
    };
    modalAddStream.addEventListener("modalopen", (ev) => {
        modalAddStream.style.display = "block";
        [o_mouseX, o_mouseY] = [mouseX, mouseY];
        streamer.focus();
    });
    modalAddStream.addEventListener("keyup", (ev) => {
        if(ev.key === "Enter") addStreamHelper();
    });
    btnOK.addEventListener("mouseup", addStreamHelper);
    btnCancel.addEventListener("mouseup", (ev) => {
        modalAddStream.style.display = "";
    });
}

let iframeEnabledWindow = null;
const disableIframes = () => {
    const winEls = document.querySelectorAll(".window.iframe-enabled");
    for(const el of winEls.values()) {
        el.classList.remove("iframe-enabled");
    }
    iframeEnabledWindow = null;
}

const enableIframe = (win) => {
    disableIframes();
    iframeEnabledWindow = win;
    win.element.classList.add("iframe-enabled");
};

document.addEventListener("mouseover", (ev) => {
    if(iframeEnabledWindow !== null) {
        if(isContainedIn(ev.target, iframeEnabledWindow.element) === false)
            disableIframes();
    }
});

// Twitch methods
const defaultTwitchOptions = {
    volume: 0.5,
    quality: "auto",
    maximizedVolume: 1,
    maximizedQuality: "chunked"
};
const twitchComponents = {};
const interpretTwitchComponents = (serialization) => {
    const obj = JSON.parse(serialization);
    for(const key of Object.keys(obj)) {
        const each = obj[key];
        const win = Window.windows.get(key);
        if(win === null) return false;
        addTwitchComponent(win, each.channel, each.chat, each.options);
    }
    return true;
};
const addTwitchComponent = (win, channel, chat, options) => {
    const id = win.contentElement.id;
    win.setTitle(`${channel}`);
    options = {...defaultTwitchOptions, ...options};
    if(!chat) {
        const player = new Twitch.Player(id, {
            channel,
            parent: [window.location.hostname]
        });
        const setOptions = () => {
            player.setMuted(false);
            player.setVolume(win.isMaximized(true) ? options.maximizedVolume : options.volume);
            player.setQuality(win.isMaximized(true) ? options.maximizedQuality : options.quality);
        };
        player.addEventListener(Twitch.Player.READY, () => {
            setOptions();
        });
        player.addEventListener(Twitch.Player.ONLINE, () => {
            win.element.classList.remove("twitch-offline");
        });
        player.addEventListener(Twitch.Player.PLAY, () => {
            win.element.classList.remove("twitch-offline");
        });
        player.addEventListener(Twitch.Player.OFFLINE, () => {
            win.element.classList.add("twitch-offline");
        });
        win.addEventListener("maximize", () => {
            setOptions();
        });
    } else {
        const iframe = createElement("iframe");
        iframe.src = `https://www.twitch.tv/embed/${channel}/chat?parent=${window.location.hostname}`;
        win.contentElement.appendChild(iframe);
    }
    twitchComponents[win.id] = {
        channel,
        chat,
        options
    };

    localStorage.setItem("t3d-twitch", JSON.stringify(twitchComponents));
};

/*

{
    windows: [
        // from dll.head to tail reversed
        {
            id: ...,
            top: ...,
            left: ...,
            width: ...,
            height: ...,
            connectedTo: [...ids],
            xMaximized: false,
            yMaximized: false
        }
    ],
    windowsTwitch: {
        "window-id": {
            channel: "...",
            chat: false,
            volume: 0.0,
            quality: "...",
            maximizedVolume: 0.0,
            maximizedQuality: "..."
        }
    }
}

*/

{
    const t3dWindows = localStorage.getItem("t3d-windows");
    if(t3dWindows !== null) Window.interpretSerialization(t3dWindows);
    const t3dTwitch = localStorage.getItem("t3d-twitch");
    if(t3dTwitch !== null) interpretTwitchComponents(t3dTwitch);
}

        </script>
    </body>
</html>